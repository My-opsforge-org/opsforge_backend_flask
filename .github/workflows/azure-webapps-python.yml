name: Deploy Flask app to Azure VM

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Reset DB and migrations (for dev/test only!)
      - name: Drop all tables in the database
        run: |
          python init_db.py
        env:
          FLASK_ENV: production
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Delete migrations directory
        run: |
          rm -rf migrations

      - name: Initialize DB migrations
        run: |
          export FLASK_APP=manage.py && flask db init || true
        env:
          FLASK_ENV: production
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Generate migration
        run: |
          export FLASK_APP=manage.py && flask db migrate "Auto migration" || true
        env:
          FLASK_ENV: production
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      # Only apply migrations; do not generate or initialize in CI/CD to avoid altering existing tables
      - name: Apply DB migrations
        run: |
          export FLASK_APP=manage.py && flask db upgrade
        env:
          FLASK_ENV: production
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Clean app directory on VM
        run: |
          sshpass -p ${{ secrets.VM_PASSWORD }} ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ secrets.VM_PUBLIC_IP }} "\
            rm -rf /home/${{ secrets.VM_USERNAME }}/app && \
            mkdir -p /home/${{ secrets.VM_USERNAME }}/app \
          "

      - name: Copy code to VM
        run: |
          sshpass -p ${{ secrets.VM_PASSWORD }} scp -o StrictHostKeyChecking=no -r . ${{ secrets.VM_USERNAME }}@${{ secrets.VM_PUBLIC_IP }}:/home/${{ secrets.VM_USERNAME }}/app

      - name: Install dependencies and start app on VM
        run: |
          sshpass -p ${{ secrets.VM_PASSWORD }} ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ secrets.VM_PUBLIC_IP }} "\
            cd /home/${{ secrets.VM_USERNAME }}/app && \
            sudo apt update && sudo apt install python3 python3-pip python3-venv -y && \
            python3 -m venv venv && \
            source venv/bin/activate && \
            pip install --upgrade pip && \
            pip install -r requirements.txt && \
            pkill -f gunicorn || true \
          "

      - name: Start Gunicorn after delay
        run: |
          sshpass -p ${{ secrets.VM_PASSWORD }} ssh -o StrictHostKeyChecking=no ${{ secrets.VM_USERNAME }}@${{ secrets.VM_PUBLIC_IP }} "\
            cd /home/${{ secrets.VM_USERNAME }}/app && \
            source venv/bin/activate && \
            sleep 5 && \
            nohup gunicorn -w 4 -b 0.0.0.0:8000 manage:app > gunicorn.log 2>&1 & \
            sleep 3 && \
            pgrep -af gunicorn \
          "

# Required secrets:
# VM_PUBLIC_IP: The public IP of your Azure VM (from Terraform output)
# VM_USERNAME: The admin username for your VM (e.g., azureuser)
# VM_PASSWORD: The admin password for your VM
# DATABASE_URL: Your PostgreSQL connection string

# Instructions:
# 1. Paste your actual publish profile XML in the publish-profile field above.
# 2. The app will use the values set by Terraform at runtime.
# 3. The workflow runs on push to main and can be triggered manually. 